from __future__ import divisionfrom visual import *import mathscene.range=300#set the vertical size of the screenscene.width=500#set the horizontal size of the screenscene.autoscale=0#turn off autoscaling#create objects{ball=sphere(pos=(0,-10,0),radius=30,color=color.red)#create ballobs1=box(pos=(150,150,0),height=175,length=75,width=100,color=color.green)#create top of obstacleobs2=box(pos=(150,-150,0),height=175,length=75,width=100,color=color.green)#create bottom of obstacle#}#obs1=cylinder(pos=(150,150,0),axis=(0,150,0),radius=75/2,color=color.green)#obs2=cylinder(pos=(150,-150,0),axis=(0,150,0),radius=75/2,color=color.green)m=1/2#just a constanth1=m*obs1.height#the upper obstacle's half length(from center to its bottom orthogonally)h2=m*obs2.height#the bottom obstacle's half length(from center to its top orthogonally)w1=m*obs1.length#both obstacles' half width(from center to it's edge orthogonally)r=ball.radius#ball's radiusVx=1#obstacle movement velocitybx=1dt=1#time divisionvector1=ball.pos-obs1.pos#vector pointing from center of ball to center of top obstaclevector2=ball.pos-obs2.pos#vector pointing from center of ball to center of bottom obstaclec1=sqrt(w1**2+h1**2)#the distance from center to its corner of the upper obstaclec2=sqrt(w1**2+h2**2)#the distance from center to its corner of the bottom obstaclecheck=True#boolean to keep program running#handle when user presses arrow key{def handleKeyDown(evt):    if check:        if evt.key == 'down' and ball.y < -m*scene.width+r:#if DOWN and the ball is at the bottom of the screen, don't move            sleep(0)        elif evt.key == 'down' and ball.y > -m*scene.width+r:#if DOWN and the ball is not at the bottom of the screen, can move            ball.pos = ball.pos + (0,-10,0)        if evt.key == 'up' and ball.y > m*scene.width-r:#if UP and the ball is at the top of the screen, don't move            sleep(0)        elif evt.key == 'up' and ball.y < m*scene.width-r:#if UP and the ball is not at the top of the screen, can move            ball.pos = ball.pos + (0,40,0)#}        scene.bind('keydown', handleKeyDown)#when the user presses a key, go to key handler#while program is running{while check:    rate(100)#rate at which program runs    if abs(vector1.x)<=w1+r:#the whole phrase        #the phrase the ball is above or below the end of obstacles        if abs(vector1.x)>w1:            #the phrase the ball is upper or below than the ends of obstacles            if ball.pos.y>=obs1.pos.y-h1 or ball.pos.y<=obs2.pos.y+h2:                    print '1'                    check=False            #the phrase the ball is between the entrance but doesn't move into the place where            #between the obstacles yet            elif c1-r<mag(vector1)<c1+r or c2-r<mag(vector2)<c2+r:                print '2'                check=False        else:            if abs(abs(vector1.y)-r)<=h1 or abs(abs(vector2.y)-r)<=h2:                print '3'                print abs(vector1.y)-r                check=False                obs1.pos.x=obs1.pos.x-Vx*dt#move the obstacles across the screen    obs2.pos.x=obs2.pos.x-Vx*dt        if obs1.x +2*w1<-m*mag(scene.range) :        obs1.x=mag(scene.range)*m+w1        obs2.x=mag(scene.range)*m+w1    ball.y=ball.y-bx*dt    if ball.y < mag(scene.range)*-1/2:        check=False            vector1=ball.pos-obs1.pos#update the ball to obstacle vectors    vector2=ball.pos-obs2.pos#}    